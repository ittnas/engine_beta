#include "program.hpp"


void Program::set_uniform_block_binding(std::string ubo_name, GLuint binding_point) {
  GLuint ubo_index = glGetUniformBlockIndex(get_program_ident(),ubo_name.c_str());
  assert(ubo_index != GL_INVALID_INDEX);
  //Last parameter should be global_ubo_binding_point
  glUniformBlockBinding(get_program_ident(),ubo_index,binding_point);
}

Program::Program(const std::string &vertex_shader_file_name, const std::string &fragment_shader_file_name,const std::string &geometry_shader_file_name) {
  GLuint vertex_shader_ident = load_shader(GL_VERTEX_SHADER,vertex_shader_file_name);
  GLuint fragment_shader_ident = load_shader(GL_FRAGMENT_SHADER,fragment_shader_file_name);
  GLuint shader_program_ident = glCreateProgramObjectARB();
  glAttachObjectARB(shader_program_ident,vertex_shader_ident);
  glAttachObjectARB(shader_program_ident,fragment_shader_ident);

  if(!geometry_shader_file_name.empty()) {
    GLuint geometry_shader_ident = load_shader(GL_GEOMETRY_SHADER,geometry_shader_file_name);
    glAttachObjectARB(shader_program_ident,geometry_shader_ident);
  }

  glLinkProgramARB(shader_program_ident);
  //glUseProgramObjectARB(shader_program_ident);
  //glUseProgram(shader_program_ident);
  this->program_ident = shader_program_ident;
}

GLuint Program::load_shader(GLenum shader_type, const std::string &shader_file_name) {
  // Look for local name first
  std::string full_name = LOCAL_FILE_DIR + shader_file_name;
  std::ifstream test_file(full_name.c_str());
  GLuint shader_ident;
  if(test_file.is_open()) {
    shader_ident = create_shader(shader_type,test_file);
    return shader_ident;
  }
  full_name = GLOBAL_FILE_DIR + shader_file_name;
  std::ifstream test_file2(full_name.c_str());
    if(test_file2.is_open()) {
      shader_ident = create_shader(shader_type,test_file2);
      return shader_ident;
    }
    throw std::runtime_error("Could not find the file " + shader_file_name);
}

GLuint Program::create_shader(GLenum shader_type, std::ifstream &shader_file_stream) {
  std::stringstream shader_data;
  shader_data << shader_file_stream.rdbuf();
  //std::cout << shader_data.str() << std::endl;
  shader_file_stream.close();
  GLuint shader_ident = glCreateShader(shader_type);
  std::string temp_string = shader_data.str();
  const GLchar * source_string =temp_string.c_str(); // If this is done in one step the data the pointer points to gets destroyd after this line. The shader will then be randomly corrupted.
  //const GLchar * source_string = shader_data.str().c_str();
  glShaderSource(shader_ident,1,&source_string,NULL);
  glCompileShaderARB(shader_ident);
  GLint status = 0;

  glGetShaderiv(shader_ident,GL_COMPILE_STATUS,&status);
  if(!status) {
  //if(1) { //Always print infolog
    GLsizei maxlength = 200;
    GLsizei * length = (GLsizei *)malloc(sizeof(GLsizei));
    GLchar * infolog = (GLchar *)malloc(sizeof(GLchar)*maxlength);
    glGetShaderInfoLog(shader_ident,maxlength,length,infolog);
    std::cout << "Compilation error:" << std::endl << infolog;
    free(length);
    free(infolog);
  }
  std::cout << shader_type << ": " << status << std::endl;
  
  return shader_ident;
}
