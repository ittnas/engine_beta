#include <glm/gtc/type_ptr.hpp>

#include "rigid_body.hpp"

glm::vec3 RigidBody::calculate_center_of_mass(GLuint attribute_array_index,GLuint density_array_index) {
  glm::vec3 center_of_mass = glm::vec3(0,0,0);
  for(auto child : get_children()) {
    RigidBody * rb = dynamic_cast<RigidBody *>(child);
    if(rb != 0) {
      center_of_mass += rb->calculate_center_of_mass(attribute_array_index,density_array_index);
    }
  }
  if(get_shape() != 0) {
    Mesh * mesh = get_shape()->get_mesh();
    //center_of_mass += mesh->get_center_of_mass(attribute_array_index,density_array_index);
    center_of_mass += mesh->get_center_of_mass(attribute_array_index);
  }
}

void RigidBody::set_uniform_mass(GLfloat mass) {
  this->inverse_mass = 1/mass;
}

void RigidBody::set_uniform_density(GLfloat density) {
  this->density = density;
}

/**
   Calculates the moment of inertia
 **/

void RigidBody::set_moment_of_inertia_and_mass(GLuint position_array_index,GLuint density_array_index) {
  glm::mat3 moment_of_inertia;
  glm::vec3 center_of_mass;
  GLfloat mass;
  calculate_moment_of_inertia(moment_of_inertia,center_of_mass,mass,position_array_index,density_array_index);
  this->inverse_moment_of_inertia = glm::inverse(moment_of_inertia);
  this->center_of_mass = center_of_mass;
  this->inverse_mass = 1/mass;
}

void RigidBody::calculate_moment_of_inertia(glm::mat3 & moment_of_inertia, glm::vec3 & center_of_mass,GLfloat & mass,GLuint position_array_index,GLuint density_array_index) {
  moment_of_inertia = glm::mat3(0.0);
  mass = 0.0;
  center_of_mass = glm::vec3(0.0);
  for(auto child : get_children()) {
    RigidBody * rb = dynamic_cast<RigidBody *>(child);
    if(rb != 0) {
      glm::mat3 target_moment_of_inertia = glm::mat3(0.0);
      glm::vec3 target_center_of_mass = glm::vec3(0,0,0);
      GLfloat target_mass = 0.0;
      rb->calculate_moment_of_inertia(target_moment_of_inertia,target_center_of_mass,target_mass,position_array_index,density_array_index);
      
      mass += target_mass;
      center_of_mass += target_mass*(target_center_of_mass + glm::vec3(rb->get_position()));
      scale_moment_of_inertia(target_moment_of_inertia,rb->get_uniform_scale());
      rotate_moment_of_inertia(target_moment_of_inertia,glm::mat3_cast(rb->get_orientation()));
      translate_moment_of_inertia(target_moment_of_inertia,glm::vec3(rb->get_position().x,rb->get_position().y,rb->get_position().z),target_mass,target_center_of_mass);
      moment_of_inertia += target_moment_of_inertia;
    }
  }
  if(get_shape() != 0) {
    Mesh * mesh = get_shape()->get_mesh();
    moment_of_inertia += mesh->get_moment_of_inertia(position_array_index);//,glm::vec3(get_position().x,get_position().y,get_position().z));
    glm::vec3 mesh_com = mesh->get_center_of_mass(position_array_index);
    GLfloat mesh_mass = mesh->get_volume(position_array_index); // This could be optimized. Volume is also calculated alongwith center of mass.
    center_of_mass += mesh_com*mesh_mass;
    mass += mesh_mass;
    for(GLuint i = 0; i < 3; i++) {
      for(GLuint j = 0; j < 3; j++) {
	std::cout << moment_of_inertia[i][j] << ",\t";
      }
      std::cout << std::endl;
    }
  }
  center_of_mass = center_of_mass/mass;
}

glm::mat3 RigidBody::outer(const glm::vec3 & vec1,const glm::vec3 & vec2) {
  GLfloat output[9] = {vec1.x*vec2.x,vec1.x*vec2.y,vec1.x*vec2.z,
		       vec1.y*vec2.x,vec1.y*vec2.y,vec1.y*vec2.z,
		       vec1.z*vec2.x,vec1.z*vec2.y,vec1.z*vec2.z};
  return glm::make_mat3(output);
}

void RigidBody::translate_moment_of_inertia(glm::mat3 & moment_of_inertia,const glm::vec3 & distance, GLfloat mass, const glm::vec3 & center_of_mass) {
  glm::mat3 deflection = mass*(outer(distance,distance) + outer(distance,center_of_mass) + outer(center_of_mass,distance));
  moment_of_inertia += glm::mat3(1.0)*(deflection[0][0] + deflection[1][1] + deflection[2][2]) - deflection;
}

void RigidBody::rotate_moment_of_inertia(glm::mat3 &moment_of_inertia, const glm::mat3 & rotation_matrix) {
  moment_of_inertia = rotation_matrix*moment_of_inertia*glm::transpose(rotation_matrix);
}

void RigidBody::scale_moment_of_inertia(glm::mat3 & moment_of_inertia,GLfloat scale_factor) {
  moment_of_inertia =  std::pow(scale_factor,5)*moment_of_inertia;
}

RigidBody::RigidBody() : Object(), density(1.0), previous_tick(-1), velocity(glm::vec3(0,0,0)), angular_velocity(glm::vec3(0,0,0)) {
  
}

void RigidBody::apply_impulse(const glm::vec3 & impulse, const glm::vec3 & position) {
  angular_velocity += inverse_moment_of_inertia*glm::cross(position - center_of_mass, impulse);
  velocity += impulse*inverse_mass;
}

void RigidBody::update_motion(GLuint tick) {
  if(tick == -1) {
    previous_tick = tick;
    return;
  }
  GLfloat dt = (GLfloat)(tick-previous_tick)/1000;
  std::cout << "dt: " << dt << std::endl;
  glm::vec4 new_position = get_position() + glm::vec4(velocity.x,velocity.y,velocity.z,0)*dt;
  set_position(new_position);
  GLfloat av_norm = std::sqrt(angular_velocity.x*angular_velocity.x+angular_velocity.y*angular_velocity.y+angular_velocity.z*angular_velocity.z);
  if(av_norm != 0)  {
    glm::fquat new_orientation = glm::fquat(std::cos(av_norm*dt/2),angular_velocity.x*std::sin(av_norm*dt/2)/av_norm,angular_velocity.y*std::sin(av_norm*dt/2)/av_norm,angular_velocity.z*std::sin(av_norm*dt/2)/av_norm);
    glm::fquat previous_orientation = get_orientation();
    new_orientation = new_orientation*previous_orientation;
    std::cout << "Orientation: " << "x: " << new_orientation.x << " y: " << new_orientation.y << " z: " << new_orientation.z << " w: " << new_orientation.w << std::endl;
  set_orientation(new_orientation);
  }
  previous_tick = tick;
}
