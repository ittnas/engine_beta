#include "flying_camera.hpp"

/** 
 * Creates the orientation quaternion from given axis and angle. The axis is NOT normalized by this function. If a unit quaternion is required, the axis should be normalized in advance.
 * 
 * @param axis Axis around which rotation rotation is performed.
 * @param angle Angle of rotation in degrees.
 * 
 * @return Orientation quaternion representing the rotation around given axis by given degrees.
 */
const glm::fquat FlyingCamera::create_quaternion(const glm::vec3 & axis, GLfloat angle) {
  GLfloat angled2 = deg_to_rad_d2(angle);
  glm::vec3 body = axis*sinf(angled2);
  GLfloat scalar = cosf(angled2);

  return glm::fquat(scalar,body.x,body.y,body.z);
}

/** 
 * Rotates the camera around the y-axis by given angle. Note that the axis is specifed in camera space.
 * 
 * @param angle Angle of rotation.
 */

void FlyingCamera::yaw(GLfloat angle) {
  glm::fquat quaternion = create_quaternion(get_up_dir(),angle);
  forward = quaternion*forward;
  up = quaternion*up;
}

void FlyingCamera::pitch(GLfloat angle) {
  glm::fquat quaternion = create_quaternion(glm::cross(forward_dir,up_dir),angle);
  forward = quaternion*forward;
  up = quaternion*up;
}

void FlyingCamera::roll(GLfloat angle) {
  glm::fquat quaternion = create_quaternion(forward_dir,angle);
  up = quaternion*up;
  forward = quaternion * forward;
}

void FlyingCamera::move_to_point(glm::vec3 target_point) {
  position = target_point;
}

void FlyingCamera::move_to_direction(const glm::vec3 & direction, GLfloat distance) {
  glm::vec3 normalized_direction = glm::normalize(direction);
  position = position + normalized_direction*distance;
}

void FlyingCamera::move_forward(GLfloat distance) {
  glm::mat3 rotation = glm::mat3_cast(forward);
  // The order of multiplication is reversed... now it seems to be working quite fine.
  glm::vec3 axis_of_motion = forward_dir*rotation;
  // axis_of_motion should be normalized
  position = position + axis_of_motion*distance;

}
void FlyingCamera::move_backward(GLfloat distance) {
  move_forward(-distance);
}

const GLfloat FlyingCamera::deg_to_rad_d2(GLfloat angle_in_degs) 
{
  return angle_in_degs*0.0087266461111111; // \theta_rad/2 = 2*pi/360*\theta_deg/2
}
