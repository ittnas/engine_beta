#include <assert.h>
#include <limits> 
#include <glm/glm.hpp>
#include <cstring>
#include <GL/glew.h>
#include <iostream>

#include "simple_collision_detector.hpp"

AABB * SimpleCollisionDetector::generate_AABB(Mesh * mesh, GLuint position_array_index) {
  AttributeArray * position_array = mesh->get_attribute_array(position_array_index);

  assert(position_array->get_nbr_elements_per_vertex() == 4);
  GLfloat * data = position_array->get_data();
  GLfloat max[3] = {-std::numeric_limits<GLfloat>::max(),-std::numeric_limits<GLfloat>::max(),-std::numeric_limits<GLfloat>::max()};
  GLfloat min[3] = {std::numeric_limits<GLfloat>::max(),std::numeric_limits<GLfloat>::max(),std::numeric_limits<GLfloat>::max()};
  for(GLuint i = 0; i < position_array->get_nbr_vertices(); i++) {
    for(GLuint j = 0; j < 3; j++) {
      if(data[i*4 + j] > max[j]) {
	max[j] = data[i*4+j];
      }
      if(data[i*4 + j] < min[j]) {
	min[j] = data[i*4+j];
      }
    }
  }
  return new AABB(min,max);
}

void SimpleCollisionDetector::multiply_AABB_with_matrix(AABB * source, AABB * destination, const glm::mat4 & model_matrix) {
  glm::vec4 new_vertices[8];
  glm::vec4 * old_vertices = source->get_vertices();
  for(GLuint i = 0; i < 8; i++) {
    new_vertices[i] = model_matrix * old_vertices[i];
  }
  GLfloat min[3] = {std::numeric_limits<GLfloat>::max(),std::numeric_limits<GLfloat>::max(),std::numeric_limits<GLfloat>::max()};
  GLfloat max[3] = {-std::numeric_limits<GLfloat>::max(),-std::numeric_limits<GLfloat>::max(),-std::numeric_limits<GLfloat>::max()};
  
  for(GLuint i = 0; i < 8; i++) {
    if(new_vertices[i].x < min[0]) {
      min[0] = new_vertices[i].x;
    }
    if(new_vertices[i].y < min[1]) {
      min[1] = new_vertices[i].y;
    }
    if(new_vertices[i].z < min[2]) {
      min[2] = new_vertices[i].z;
    }
    if(new_vertices[i].x > max[0]) {
      max[0] = new_vertices[i].x;
    }
    if(new_vertices[i].y > max[1]) {
      max[1] = new_vertices[i].y;
    }
    if(new_vertices[i].z > max[2]) {
      max[2] = new_vertices[i].z;
    }
  }
  destination->set_min_max(min,max);
}

void SimpleCollisionDetector::add_object(Object * object) {
  UniformMaterial * mv = dynamic_cast<UniformMaterial *>(object);
  if(mv != 0 && object->get_shape() != 0) {
    objects.push_back(mv);
    Mesh * mesh =  mv->get_shape()->get_mesh();
    AABBs_from_mesh.push_back(generate_AABB(mesh,0));
    GLfloat min[3];
    GLfloat max[3];
    AABBs.push_back(new AABB(min,max));
  }
}

void SimpleCollisionDetector::apply_transformations() {
  for(GLuint i = 0; i < objects.size(); i++) {
    multiply_AABB_with_matrix(AABBs_from_mesh[i],AABBs[i],objects[i]->get_model_matrix());
  }
}

void SimpleCollisionDetector::detect_collisions() {
  for(GLuint i = 0; i < AABBs.size(); i++) {
    for(GLuint j = i+1; j < AABBs.size(); j++) {
      if(collision_takes_place(AABBs[i],AABBs[j])) {
	objects[i]->set_ambient_color(glm::vec4(0.2,0.0,0.0,1.0));
	objects[j]->set_ambient_color(glm::vec4(0.2,0.0,0.0,1.0));
      } else {
	objects[i]->set_ambient_color(glm::vec4(0.0,0.2,0.0,1.0));
	objects[j]->set_ambient_color(glm::vec4(0.0,0.2,0.0,1.0));
      }
    }
  }
}

GLboolean SimpleCollisionDetector::collision_takes_place(AABB * obj1, AABB* obj2) {
  //std::cout << "obj1 max: " << obj1->get_max()[0] << "," << obj1->get_max()[1] << "," << obj1->get_max()[2] << " min: " << obj1->get_min()[0] << "," << obj1->get_min()[1] << "," << obj1->get_min()[2] << std::endl;
  //std::cout << "obj2 max: " << obj2->get_max()[0] << "," << obj2->get_max()[1] << "," << obj2->get_max()[2] << " min: " << obj2->get_min()[0] << "," << obj2->get_min()[1] << "," << obj2->get_min()[2] << std::endl;
  for(GLuint i = 0; i < 3; i++) {
    if(obj1->get_max()[i] < obj2->get_min()[i] || obj1->get_min()[i] > obj2->get_max()[i]) {
      return false;
    }
  }
  return true;
}
