#include "collision_hierarchy_node.hpp"
#include "bounding_geometry_type.hpp"
#include "bounding_geometry_generation_algorithms.hpp"
#include "world.hpp"

CollisionHierarchyNode::CollisionHierarchyNode(CollisionObject * object) : collision_object(object) {
  
}

void CollisionHierarchyNode::generate_bounding_geometry(const std::vector<BoundingGeometry *> & source_geometries) {
  //TODO handle source_geometries
    BoundingGeometryType preferred_bounding_geometry = collision_object->get_preferred_bounding_volume();
    std::vector<glm::vec4> mesh;
    collision_object->get_transformed_mesh_points(mesh,0);
    if(local_bounding_geometry != NULL) {
      delete local_bounding_geometry;
    }
    switch(preferred_bounding_geometry) {
    case SPHERE:
      local_bounding_geometry = BGAlgorithm::ritters_algorithm(mesh);
      break;
    default:
      local_bounding_geometry = BGAlgorithm::ritters_algorithm(mesh);
    }
    //TODO handle composition from many bounding geometries
}

GLboolean CollisionHierarchyNode::create_bounding_geometry_object(Program * prog) {
  if(local_bounding_geometry != NULL) {
    bounding_geometry_object = new Movable();
    bounding_geometry_object->set_shape(local_bounding_geometry->create_shape());
    bounding_geometry_object->set_program(prog);
    Object * parent = collision_object->get_parent();
    if(parent != NULL) {
      parent->add_child(bounding_geometry_object);
    } else {
      World * collision_object_home_world = collision_object->get_world();
      if(collision_object_home_world == NULL) {
	assert(0); // This is actually an error
	return GL_FALSE;
      }
      collision_object_home_world->add_child(bounding_geometry_object);
    }
    return GL_TRUE;
  } else {
    return GL_FALSE;
  }
}

void CollisionHierarchyNode::update_bounding_geometry_object() {
  //TODO
}
