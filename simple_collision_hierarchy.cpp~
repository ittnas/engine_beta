#include <memory>
#include "simple_collision_hierarchy.hpp"

void SimpleCollisionHierarchy::get_intersecting_pairs(std::vector<std::unique_ptr<CollisionPair>> & input) {
  for(GLuint i = 0; i < collision_hierarchy_nodes.size(); i++) {
    for(GLuint j = i+1;j < collision_hierarchy_nodes.size(); j++) {
      //TODO check if bounding geometries exist
      GLboolean intersect_true = collision_hierarchy_nodes[i]->get_bounding_geometry()->accept(*(collision_hierarchy_nodes[j]->get_bounding_geometry()));
      if(intersect_true) {
	std::unique_ptr<CollisionPair> cp(new CollisionPair(collision_hierarchy_nodes[i]->get_collision_object(),collision_hierarchy_nodes[j]->get_collision_object()));
	input.push_back(std::move(cp));
      }
    }
  }
}

void SimpleCollisionHierarchy::add_object(CollisionObject *co) {
  CollisionHierarchyNode * coh = new CollisionHierarchyNode(co);
  coh->generate_bounding_geometry();
  collision_hierarchy_nodes.push_back(coh);
  // Update the bounding geometries
}

void SimpleCollisionHierarchy::remove_object(CollisionObject * co) {
  for(auto it = collision_hierarchy_nodes.begin(); it != collision_hierarchy_nodes.end();) {
    if((*it)->get_collision_object() == co) {
      it = collision_hierarchy_nodes.erase(it);
      delete *it;
    } else {
      ++it;
    }
  }
  //TODO next update the bounding geometries (global ones)
}

void SimpleCollisionHierarchy::notify_about_mesh_change(CollisionObject * co) {
  //TODO
}

// Is this even necessary?
void SimpleCollisionHierarchy::notify_about_position_change(CollisionObject * co) {
  //TODO
}

SimpleCollisionHierarchy::~SimpleCollisionHierarchy() {
  for(auto child : collision_hierarchy_nodes) {
    delete child;
  }
}

void SimpleCollisionHierarchy::update_bounding_geometries() {
  for(auto child : collision_hierarchy_nodes) {
    child->update_bounding_geometry();
  }
}

SimpleCollisionHierarchy::SimpleCollisionHierarchy() {
}
